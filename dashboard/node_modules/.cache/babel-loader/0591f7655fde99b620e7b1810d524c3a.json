{"ast":null,"code":"'use client';\n\nimport { createContext, Component, isValidElement, createElement, useContext, useState, useMemo, forwardRef } from 'react';\nconst ErrorBoundaryContext = createContext(null);\nconst initialState = {\n  didCatch: false,\n  error: null\n};\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props; // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if (isValidElement(fallback)) {\n        childToRender = fallback;\n      } else if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else {\n        throw new Error(\"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\");\n      }\n    }\n\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n\n}\n\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\n\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n\n  return true;\n}\n\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context === null || context === void 0 ? void 0 : context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context === null || context === void 0 ? void 0 : context.resetErrorBoundary]);\n\n  if (state.hasError) {\n    throw state.error;\n  }\n\n  return memoized;\n}\n\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, { ...props,\n    ref\n  }))); // Format for display in DevTools\n\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\n\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };","map":{"version":3,"sources":["F:/FSD-FT/project/New folder/New folder/crypto/dashboard/node_modules/react-error-boundary/dist/react-error-boundary.esm.js"],"names":["createContext","Component","isValidElement","createElement","useContext","useState","useMemo","forwardRef","ErrorBoundaryContext","initialState","didCatch","error","ErrorBoundary","constructor","props","resetErrorBoundary","bind","state","getDerivedStateFromError","_this$props$onReset","_this$props","_len","arguments","length","args","Array","_key","onReset","call","reason","setState","componentDidCatch","info","_this$props$onError","_this$props2","onError","componentDidUpdate","prevProps","prevState","resetKeys","hasArrayChanged","_this$props$onReset2","_this$props3","next","prev","render","children","fallbackRender","FallbackComponent","fallback","childToRender","Error","Provider","value","a","undefined","b","some","item","index","Object","is","assertErrorBoundaryContext","useErrorBoundary","context","hasError","memoized","resetBoundary","showBoundary","withErrorBoundary","component","errorBoundaryProps","Wrapped","ref","name","displayName","concat"],"mappings":"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","sourcesContent":["'use client';\nimport { createContext, Component, isValidElement, createElement, useContext, useState, useMemo, forwardRef } from 'react';\n\nconst ErrorBoundaryContext = createContext(null);\n\nconst initialState = {\n  didCatch: false,\n  error: null\n};\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n      if (isValidElement(fallback)) {\n        childToRender = fallback;\n      } else if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else {\n        throw new Error(\"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\");\n      }\n    }\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n}\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\n\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n  return true;\n}\n\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context === null || context === void 0 ? void 0 : context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context === null || context === void 0 ? void 0 : context.resetErrorBoundary]);\n  if (state.hasError) {\n    throw state.error;\n  }\n  return memoized;\n}\n\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, {\n    ...props,\n    ref\n  })));\n\n  // Format for display in DevTools\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\n\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };\n"]},"metadata":{},"sourceType":"module"}